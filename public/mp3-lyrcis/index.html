<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>MP3 ID3 + Lyrics Editor & Builder (Fixed)</title>
  <script src="https://cdn.jsdelivr.net/npm/jsmediatags@3.9.7/dist/jsmediatags.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/pako@2.1.0/dist/pako.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/browser-id3-writer@4.4.0/dist/browser-id3-writer.min.js"></script>
  <style>
    body { font-family: Arial, sans-serif; max-width: 1200px; margin: 0 auto; padding: 20px; background: #f5f5f5; }
    .container { background: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); margin-bottom: 20px; }
    .file-input { margin-bottom: 20px; padding: 10px; border: 2px dashed #ccc; border-radius: 8px; text-align: center; }
    textarea { width: 100%; height: 400px; font-family: monospace; font-size: 12px; padding: 10px; border: 1px solid #ddd; border-radius: 4px; resize: vertical; }
    button { background: #007bff; color: white; border: none; padding: 10px 20px; border-radius: 4px; cursor: pointer; margin: 5px; }
    button:hover { background: #0056b3; }
    button:disabled { background: #6c757d; cursor: not-allowed; }
    .download-link { display: inline-block; background: #28a745; color: white; text-decoration: none; padding: 10px 20px; border-radius: 4px; margin: 5px; }
    .download-link:hover { background: #1e7e34; }
    .error { color: #dc3545; background: #f8d7da; padding: 10px; border-radius: 4px; margin: 10px 0; }
    .success { color: #155724; background: #d4edda; padding: 10px; border-radius: 4px; margin: 10px 0; }
    .warning { color: #856404; background: #fff3cd; padding: 10px; border-radius: 4px; margin: 10px 0; }
    .info { background: #e7f3ff; padding: 15px; border-radius: 4px; margin: 10px 0; border-left: 4px solid #007bff; }
  </style>
</head>
<body>
  <h1>MP3 Lyrics Editor & Builder (Fixed Version)</h1>
  
  <div class="info">
    <strong>‡∏Å‡∏≤‡∏£‡∏õ‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∏‡∏á:</strong>
    <ul>
      <li>‡πÉ‡∏ä‡πâ‡πÑ‡∏•‡∏ö‡∏£‡∏≤‡∏£‡∏µ browser-id3-writer ‡πÄ‡∏ß‡∏≠‡∏£‡πå‡∏ä‡∏±‡∏ô‡πÉ‡∏´‡∏°‡πà‡∏Å‡∏ß‡πà‡∏≤ (4.4.0)</li>
      <li>‡∏õ‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∏‡∏á‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£ ArrayBuffer ‡πÉ‡∏´‡πâ‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á</li>
      <li>‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á‡∏Ç‡∏≠‡∏á‡πÑ‡∏ü‡∏•‡πå</li>
      <li>‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Å‡∏≤‡∏£ backup ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏î‡∏¥‡∏°</li>
      <li>Build button ‡∏à‡∏∞ parse JSON ‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥ - ‡πÑ‡∏°‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏î Re-parse ‡πÅ‡∏•‡πâ‡∏ß!</li>
      <li><strong>Decode/Encode ‡∏ä‡∏∑‡πà‡∏≠‡πÄ‡∏û‡∏•‡∏á ‡∏®‡∏¥‡∏•‡∏õ‡∏¥‡∏ô ‡∏≠‡∏±‡∏•‡∏ö‡∏±‡πâ‡∏° ‡∏î‡πâ‡∏ß‡∏¢ TIS-620</strong></li>
      <li><strong>‡∏ã‡πà‡∏≠‡∏ô lyricsXML ‡πÉ‡∏ô JSON (‡πÅ‡∏™‡∏î‡∏á‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡∏à‡∏≥‡πÄ‡∏õ‡πá‡∏ô)</strong></li>
    </ul>
  </div>
  
  <div class="container">
    <h2>1. Load MP3 File</h2>
    <div class="file-input">
      <input type="file" id="mp3file" accept="audio/mp3" />
      <p>Select an MP3 file with embedded lyrics to edit</p>
    </div>
  </div>

  <div class="container">
    <h2>2. Edit Parsed Data</h2>
    <textarea id="jsonEditor" placeholder="Parsed data will appear here after loading an MP3 file..."></textarea>
    <div>
      <button id="parseBtn" disabled>Re-parse from JSON</button>
      <button id="buildBtn" disabled>Build Modified MP3 (Auto-parse JSON)</button>
      <button id="validateBtn" disabled>Validate JSON</button>
    </div>
    <div id="messages"></div>
  </div>

  <div class="container" id="downloadSection" style="display: none;">
    <h2>3. Download Result</h2>
    <div id="downloadLinks"></div>
    <div class="warning">
      <strong>‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏´‡∏ï‡∏∏:</strong> ‡πÑ‡∏ü‡∏•‡πå‡∏ó‡∏µ‡πà‡∏î‡∏≤‡∏ß‡∏ô‡πå‡πÇ‡∏´‡∏•‡∏î‡∏Ñ‡∏ß‡∏£‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÄ‡∏õ‡∏¥‡∏î‡πÑ‡∏î‡πâ‡∏õ‡∏Å‡∏ï‡∏¥ ‡∏´‡∏≤‡∏Å‡∏¢‡∏±‡∏á‡∏°‡∏µ‡∏õ‡∏±‡∏ç‡∏´‡∏≤ ‡πÉ‡∏´‡πâ‡∏•‡∏≠‡∏á‡πÉ‡∏ä‡πâ‡πÇ‡∏õ‡∏£‡πÅ‡∏Å‡∏£‡∏°‡πÄ‡∏•‡πà‡∏ô MP3 ‡∏≠‡∏∑‡πà‡∏ô
    </div>
  </div>

  <script>
    let originalMP3Buffer = null;
    let parsedData = null;
    let originalFileName = "";

    function showMessage(text, type = 'success') {
      const messages = document.getElementById("messages");
      messages.innerHTML = `<div class="${type}">${text}</div>`;
      setTimeout(() => messages.innerHTML = "", 8000);
    }

    function base64ToArrayBuffer(base64) {
      try {
        const binaryString = atob(base64);
        const bytes = new Uint8Array(binaryString.length);
        for (let i = 0; i < binaryString.length; i++) {
          bytes[i] = binaryString.charCodeAt(i);
        }
        return bytes.buffer;
      } catch (error) {
        throw new Error("Invalid base64 data: " + error.message);
      }
    }

    function arrayBufferToBase64(buffer) {
      try {
        let u8arr = buffer instanceof ArrayBuffer ? new Uint8Array(buffer) : buffer;
        let binary = "";
        const chunkSize = 0x8000;
        for (let i = 0; i < u8arr.length; i += chunkSize) {
          binary += String.fromCharCode(...u8arr.subarray(i, i + chunkSize));
        }
        return btoa(binary);
      } catch (error) {
        throw new Error("Failed to convert to base64: " + error.message);
      }
    }

    function stringToTIS620(str) {
      const bytes = [];
      for (let i = 0; i < str.length; i++) {
        const char = str.charCodeAt(i);
        if (char <= 127) {
          bytes.push(char);
        } else if (char >= 0x0e01 && char <= 0x0e5b) {
          bytes.push(char - 0x0e01 + 0xa1);
        } else {
          bytes.push(0x3f); // ‡πÅ‡∏ó‡∏ô‡∏ó‡∏µ‡πà‡∏î‡πâ‡∏ß‡∏¢ '?'
        }
      }
      return new Uint8Array(bytes);
    }

    function TIS620ToString(bytes) {
      let str = "";
      for (let i = 0; i < bytes.length; i++) {
        const byte = bytes[i];
        if (byte <= 127) {
          str += String.fromCharCode(byte);
        } else if (byte >= 0xa1 && byte <= 0xfb) {
          str += String.fromCharCode(byte - 0xa1 + 0x0e01);
        } else {
          str += "?";
        }
      }
      return str;
    }

    function decodeTIS620Text(text) {
      if (!text) return "";
      try {
        // ‡∏•‡∏≠‡∏á‡πÅ‡∏õ‡∏•‡∏á‡∏à‡∏≤‡∏Å TIS-620 encoded text
        const bytes = [];
        for (let i = 0; i < text.length; i++) {
          const char = text.charCodeAt(i);
          if (char >= 0xa1 && char <= 0xfb) {
            bytes.push(char);
          } else if (char <= 127) {
            bytes.push(char);
          } else {
            bytes.push(0x3f); // ?
          }
        }
        return TIS620ToString(new Uint8Array(bytes));
      } catch (err) {
        return text; // ‡∏ñ‡πâ‡∏≤ decode ‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ ‡πÉ‡∏ä‡πâ‡∏ï‡∏±‡∏ß‡πÄ‡∏î‡∏¥‡∏°
      }
    }

    function encodeTIS620Text(text) {
      if (!text) return "";
      try {
        const tis620Bytes = stringToTIS620(text);
        let result = "";
        for (let i = 0; i < tis620Bytes.length; i++) {
          result += String.fromCharCode(tis620Bytes[i]);
        }
        return result;
      } catch (err) {
        return text; // ‡∏ñ‡πâ‡∏≤ encode ‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ ‡πÉ‡∏ä‡πâ‡∏ï‡∏±‡∏ß‡πÄ‡∏î‡∏¥‡∏°
      }
    }
    function decodeLyricsBase64(encoded) {
      const clean = encoded.replace(/^LyrHdr\d*/, "");
      const compressed = base64ToArrayBuffer(clean);
      const decompressed = window.pako.inflate(compressed);
      return TIS620ToString(decompressed);
    }

    function encodeLyricsBase64(xmlText, header = "LyrHdr1") {
      const xmlBytes = stringToTIS620(xmlText);
      const compressed = window.pako.deflate(xmlBytes, { level: 9 });
      return header + arrayBufferToBase64(compressed);
    }

    function parseKLyrXML(xmlString) {
      const parser = new DOMParser();
      const xmlDoc = parser.parseFromString(xmlString, "text/xml");
      
      // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö parsing error
      const parserError = xmlDoc.querySelector("parsererror");
      if (parserError) {
        throw new Error("XML parsing error: " + parserError.textContent);
      }
      
      const info = {};
      const infoNode = xmlDoc.querySelector("INFO");
      if (infoNode) {
        for (const child of Array.from(infoNode.children)) {
          info[child.tagName] = child.textContent || "";
        }
      }

      const lyrics = [];
      const lyricNodes = xmlDoc.querySelectorAll("LYRIC LINE");
      lyricNodes.forEach((lineNode) => {
        const words = [];
        lineNode.querySelectorAll("WORD").forEach((wordNode) => {
          const timeNode = wordNode.querySelector("TIME");
          const textNode = wordNode.querySelector("TEXT");
          const vocalNode = wordNode.querySelector("VOCAL");
          if (timeNode && textNode) {
            words.push({
              tick: parseInt(timeNode.textContent || "0", 10),
              text: textNode.textContent || "",
              vocal: vocalNode ? vocalNode.textContent || "" : ""
            });
          }
        });
        if (words.length > 0) lyrics.push(words);
      });

      return { info, lyrics };
    }

    function buildKLyrXML(infoData, lyricsData) {
      let xml = '<?xml version="1.0" encoding="UTF-8"?>\r\n<SONG_LYRIC>\r\n';
      
      if (infoData && Object.keys(infoData).length > 0) {
        xml += "  <INFO>\r\n";
        for (const [key, value] of Object.entries(infoData)) {
          // Escape XML special characters
          const escapedValue = String(value)
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/"/g, '&quot;')
            .replace(/'/g, '&#39;');
          xml += `    <${key}>${escapedValue}</${key}>\r\n`;
        }
        xml += "  </INFO>\r\n";
      }
      
      if (lyricsData && lyricsData.length > 0) {
        xml += "  <LYRIC>\r\n";
        lyricsData.forEach((line) => {
          if (line.length > 0) {
            xml += "    <LINE>\r\n";
            xml += `      <TIME>${line[0].tick}</TIME>\r\n`;
            line.forEach((word) => {
              const escapedText = String(word.text || "")
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#39;');
              const escapedVocal = String(word.vocal || "")
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#39;');
              
              xml += "      <WORD>\r\n";
              xml += `        <TIME>${word.tick}</TIME>\r\n`;
              xml += `        <TEXT>${escapedText}</TEXT>\r\n`;
              xml += `        <VOCAL>${escapedVocal}</VOCAL>\r\n`;
              xml += "      </WORD>\r\n";
            });
            xml += "    </LINE>\r\n";
          }
        });
        xml += "  </LYRIC>\r\n";
      }
      xml += "</SONG_LYRIC>\r\n";
      return xml;
    }

    function validateParsedData(data) {
      if (!data || typeof data !== 'object') {
        throw new Error("‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ï‡πâ‡∏≠‡∏á‡πÄ‡∏õ‡πá‡∏ô object");
      }
      
      if (data.lyrics && !Array.isArray(data.lyrics)) {
        throw new Error("lyrics ‡∏ï‡πâ‡∏≠‡∏á‡πÄ‡∏õ‡πá‡∏ô array");
      }
      
      if (data.info && typeof data.info !== 'object') {
        throw new Error("info ‡∏ï‡πâ‡∏≠‡∏á‡πÄ‡∏õ‡πá‡∏ô object");
      }
      
      return true;
    }

    document.getElementById("mp3file").addEventListener("change", function (e) {
      const file = e.target.files[0];
      if (!file) return;

      originalFileName = file.name;
      showMessage("‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÇ‡∏´‡∏•‡∏î‡πÑ‡∏ü‡∏•‡πå...", 'info');

      file.arrayBuffer().then(buffer => {
        // ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏™‡∏≥‡πÄ‡∏ô‡∏≤‡∏Ç‡∏≠‡∏á buffer ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏õ‡∏•‡∏≠‡∏î‡∏†‡∏±‡∏¢
        originalMP3Buffer = buffer.slice();
        
        window.jsmediatags.read(file, {
          onSuccess: function(tag) {
            try {
              const tags = tag.tags;
              const result = {
                title: decodeTIS620Text(tags.title || ""),
                artist: decodeTIS620Text(tags.artist || ""),
                album: decodeTIS620Text(tags.album || ""),
                info: {},
                lyrics: []
              };

              console.log("Decoded title:", result.title);
              console.log("Decoded artist:", result.artist);
              console.log("Decoded album:", result.album);

              let lyricsRawData = null;
              if (tags.TEXT && tags.TEXT.data) {
                lyricsRawData = tags.TEXT.data;
              } else if (tags.TXXX && Array.isArray(tags.TXXX)) {
                const textField = tags.TXXX.find(field => field.description === 'TEXT');
                if (textField) lyricsRawData = textField.data;
              }

              if (lyricsRawData) {
                try {
                  console.log("Attempting to decode lyrics...");
                  const lyricsXML = decodeLyricsBase64(lyricsRawData);
                  console.log("Decoded XML length:", lyricsXML.length);
                  console.log("XML preview:", lyricsXML.substring(0, 200));
                  
                  const klyrData = parseKLyrXML(lyricsXML);
                  result.info = klyrData.info;
                  result.lyrics = klyrData.lyrics;
                  
                  console.log("Parsed lyrics lines:", result.lyrics.length);
                  console.log("Parsed info keys:", Object.keys(result.info));
                  
                  showMessage(`MP3 ‡πÇ‡∏´‡∏•‡∏î‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à! ‡∏û‡∏ö‡πÄ‡∏ô‡∏∑‡πâ‡∏≠‡πÄ‡∏û‡∏•‡∏á ${result.lyrics.length} ‡∏ö‡∏£‡∏£‡∏ó‡∏±‡∏î`);
                } catch (err) {
                  console.error("Decode error:", err);
                  showMessage("‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÅ‡∏õ‡∏•‡∏á‡πÄ‡∏ô‡∏∑‡πâ‡∏≠‡πÄ‡∏û‡∏•‡∏á‡πÑ‡∏î‡πâ: " + err.message, 'warning');
                }
              } else {
                console.log("No lyrics data found in any frame");
                showMessage("‡πÑ‡∏°‡πà‡∏û‡∏ö‡πÄ‡∏ô‡∏∑‡πâ‡∏≠‡πÄ‡∏û‡∏•‡∏á‡πÉ‡∏ô‡πÑ‡∏ü‡∏•‡πå MP3", 'warning');
              }

              parsedData = result;
              document.getElementById("jsonEditor").value = JSON.stringify(result, null, 2);
              document.getElementById("parseBtn").disabled = false;
              document.getElementById("buildBtn").disabled = false;
              document.getElementById("validateBtn").disabled = false;
              
            } catch (error) {
              showMessage("‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•: " + error.message, 'error');
            }
          },
          onError: function(error) {
            showMessage("‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏≠‡πà‡∏≤‡∏ô‡πÑ‡∏ü‡∏•‡πå MP3 ‡πÑ‡∏î‡πâ: " + error.info, 'error');
          }
        });
      }).catch(error => {
        showMessage("‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÇ‡∏´‡∏•‡∏î‡πÑ‡∏ü‡∏•‡πå‡πÑ‡∏î‡πâ: " + error.message, 'error');
      });
    });

    document.getElementById("validateBtn").addEventListener("click", function() {
      try {
        const data = JSON.parse(document.getElementById("jsonEditor").value);
        validateParsedData(data);
        showMessage("JSON ‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á!");
      } catch (err) {
        showMessage("JSON ‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á: " + err.message, 'error');
      }
    });

    document.getElementById("parseBtn").addEventListener("click", function() {
      try {
        const data = JSON.parse(document.getElementById("jsonEditor").value);
        validateParsedData(data);
        parsedData = data;
        
        console.log("=== PARSED DATA DEBUG ===");
        console.log("Title:", data.title);
        console.log("Artist:", data.artist);
        console.log("Album:", data.album);
        console.log("Info keys:", Object.keys(data.info || {}));
        console.log("Lyrics lines:", (data.lyrics || []).length);
        if (data.lyrics && data.lyrics.length > 0) {
          console.log("First line words:", data.lyrics[0].length);
          console.log("First word:", data.lyrics[0][0]);
        }
        
        showMessage("‡πÅ‡∏õ‡∏•‡∏á JSON ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à! ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö Console ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î");
      } catch (err) {
        showMessage("JSON ‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á: " + err.message, 'error');
      }
    });

    document.getElementById("buildBtn").addEventListener("click", async function() {
      if (!originalMP3Buffer) {
        showMessage("‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÇ‡∏´‡∏•‡∏î‡πÑ‡∏ü‡∏•‡πå MP3 ‡∏Å‡πà‡∏≠‡∏ô", 'error');
        return;
      }

      try {
        showMessage("‡∏Å‡∏≥‡∏•‡∏±‡∏á build ‡πÑ‡∏ü‡∏•‡πå‡πÉ‡∏´‡∏°‡πà...", 'info');
        
        // ‡∏≠‡πà‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≤‡∏Å JSON editor ‡∏Å‡πà‡∏≠‡∏ô‡∏ó‡∏∏‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á
        console.log("=== AUTO PARSING JSON BEFORE BUILD ===");
        try {
          const currentData = JSON.parse(document.getElementById("jsonEditor").value);
          validateParsedData(currentData);
          parsedData = currentData;
          console.log("JSON parsed successfully before build");
          console.log("Updated parsedData - Info keys:", Object.keys(parsedData.info || {}));
          console.log("Updated parsedData - Lyrics lines:", (parsedData.lyrics || []).length);
        } catch (parseErr) {
          showMessage("JSON ‡πÉ‡∏ô‡∏ä‡πà‡∏≠‡∏á Editor ‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á: " + parseErr.message, 'error');
          return;
        }
        
        // Validate ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Å‡πà‡∏≠‡∏ô build
        if (!parsedData.lyrics || parsedData.lyrics.length === 0) {
          showMessage("‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏ô‡∏∑‡πâ‡∏≠‡πÄ‡∏û‡∏•‡∏á‡∏ó‡∏µ‡πà‡∏à‡∏∞ build", 'warning');
        }
        
        // ‡∏™‡∏£‡πâ‡∏≤‡∏á XML ‡πÉ‡∏´‡∏°‡πà
        console.log("=== BUILD PROCESS DEBUG ===");
        console.log("Input data - Info:", parsedData.info);
        console.log("Input data - Lyrics lines:", parsedData.lyrics.length);
        
        const newXML = buildKLyrXML(parsedData.info, parsedData.lyrics);
        console.log("Built XML length:", newXML.length);
        console.log("Built XML preview:", newXML.substring(0, 500));
        
        // ‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£ parse XML ‡∏Å‡∏•‡∏±‡∏ö
        try {
          const testParsed = parseKLyrXML(newXML);
          console.log("Test parse - Info keys:", Object.keys(testParsed.info));
          console.log("Test parse - Lyrics lines:", testParsed.lyrics.length);
          if (testParsed.lyrics.length > 0 && testParsed.lyrics[0].length > 0) {
            console.log("Test parse - First word:", testParsed.lyrics[0][0]);
          }
        } catch (testErr) {
          console.error("XML parsing test failed:", testErr);
          showMessage("XML ‡∏ó‡∏µ‡πà‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Ç‡∏∂‡πâ‡∏ô‡∏°‡∏µ‡∏õ‡∏±‡∏ç‡∏´‡∏≤: " + testErr.message, 'error');
          return;
        }
        
        const encodedLyrics = encodeLyricsBase64(newXML);
        console.log("Final encoded length:", encodedLyrics.length);
        console.log("Encoded starts with:", encodedLyrics.substring(0, 50));
        
        // ‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£ decode ‡∏Å‡∏•‡∏±‡∏ö
        try {
          const testDecoded = decodeLyricsBase64(encodedLyrics);
          console.log("Test decode success, length:", testDecoded.length);
          console.log("Decoded matches original:", testDecoded === newXML);
        } catch (decodeErr) {
          console.error("Decode test failed:", decodeErr);
          showMessage("‡∏Å‡∏≤‡∏£ encode ‡∏°‡∏µ‡∏õ‡∏±‡∏ç‡∏´‡∏≤: " + decodeErr.message, 'error');
          return;
        }

        // ‡∏™‡∏£‡πâ‡∏≤‡∏á ArrayBuffer ‡πÉ‡∏´‡∏°‡πà‡∏à‡∏≤‡∏Å originalMP3Buffer
        const audioData = new Uint8Array(originalMP3Buffer);
        
        // ‡πÉ‡∏ä‡πâ ID3Writer
        const writer = new ID3Writer(audioData);
        
        // ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ version ‡πÅ‡∏•‡∏∞ encoding
        writer.padding = 4096; // ‡πÄ‡∏û‡∏¥‡πà‡∏° padding ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏õ‡∏•‡∏≠‡∏î‡∏†‡∏±‡∏¢
        
        // ‡∏Å‡∏≥‡∏´‡∏ô‡∏î tags ‡∏ï‡πà‡∏≤‡∏á‡πÜ (encode ‡∏Å‡∏•‡∏±‡∏ö‡πÄ‡∏õ‡πá‡∏ô TIS-620)
        if (parsedData.title) {
          const encodedTitle = encodeTIS620Text(parsedData.title);
          writer.setFrame('TIT2', encodedTitle);
          console.log("Set title:", parsedData.title, "->", encodedTitle);
        }
        if (parsedData.artist) {
          const encodedArtist = encodeTIS620Text(parsedData.artist);
          writer.setFrame('TPE1', [encodedArtist]);
          console.log("Set artist:", parsedData.artist, "->", encodedArtist);
        }
        if (parsedData.album) {
          const encodedAlbum = encodeTIS620Text(parsedData.album);
          writer.setFrame('TALB', encodedAlbum);
          console.log("Set album:", parsedData.album, "->", encodedAlbum);
        }
        
        // ‡πÄ‡∏û‡∏¥‡πà‡∏° lyrics ‡πÉ‡∏ô‡∏´‡∏•‡∏≤‡∏¢‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ‡πÅ‡∏ô‡πà‡πÉ‡∏à
        console.log("=== ID3 WRITING DEBUG ===");
        console.log("Encoded lyrics length:", encodedLyrics.length);
        console.log("Encoded lyrics preview:", encodedLyrics.substring(0, 100));
        
        // ‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÉ‡∏ô TXXX frame ‡∏´‡∏•‡∏≤‡∏¢‡πÅ‡∏ö‡∏ö
        writer.setFrame('TXXX', { 
          description: 'TEXT', 
          value: encodedLyrics 
        });
        console.log("Added TXXX frame with description 'TEXT'");
        
        writer.setFrame('TXXX', { 
          description: '', 
          value: encodedLyrics 
        });
        console.log("Added TXXX frame with empty description");
        
        // ‡∏•‡∏≠‡∏á‡πÄ‡∏û‡∏¥‡πà‡∏° TXXX ‡∏≠‡∏µ‡∏Å‡πÅ‡∏ö‡∏ö
        writer.setFrame('TXXX', { 
          description: 'LYRICS', 
          value: encodedLyrics 
        });
        console.log("Added TXXX frame with description 'LYRICS'");
        
        // ‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÉ‡∏ô TEXT frame ‡∏ñ‡πâ‡∏≤‡πÄ‡∏õ‡πá‡∏ô‡πÑ‡∏õ‡πÑ‡∏î‡πâ
        try {
          writer.setFrame('TEXT', encodedLyrics);
          console.log("Added TEXT frame successfully");
        } catch (e) {
          console.log("Cannot set TEXT frame:", e.message);
        }
        
        console.log("Adding tag to buffer...");
        writer.addTag();
        console.log("Tag added successfully");

        const taggedBuffer = writer.arrayBuffer;
        console.log("=== FINAL BUFFER DEBUG ===");
        console.log("Original buffer size:", originalMP3Buffer.byteLength);
        console.log("Tagged buffer size:", taggedBuffer.byteLength);
        console.log("Size difference:", taggedBuffer.byteLength - originalMP3Buffer.byteLength);
        
        const blob = new Blob([taggedBuffer], { type: 'audio/mpeg' });
        const url = URL.createObjectURL(blob);
        
        const fileName = originalFileName.replace(/\.mp3$/i, '_modified.mp3');
        
        document.getElementById("downloadLinks").innerHTML = `
          <a href="${url}" download="${fileName}" class="download-link">
            üì• ‡∏î‡∏≤‡∏ß‡∏ô‡πå‡πÇ‡∏´‡∏•‡∏î ${fileName}
          </a>
          <p><small>‡∏Ç‡∏ô‡∏≤‡∏î‡πÑ‡∏ü‡∏•‡πå: ${(blob.size / 1024 / 1024).toFixed(2)} MB</small></p>
          <p><small>‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ç‡∏∂‡πâ‡∏ô: ${((taggedBuffer.byteLength - originalMP3Buffer.byteLength) / 1024).toFixed(1)} KB</small></p>
        `;
        document.getElementById("downloadSection").style.display = "block";
        showMessage("‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÑ‡∏ü‡∏•‡πå MP3 ‡πÉ‡∏´‡∏°‡πà‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à! ‡∏ï◊®‡∏ß‡∏à‡∏™‡∏≠‡∏ö Console ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î‡∏Å‡∏≤‡∏£ debug");
        
      } catch (err) {
        console.error("Build error:", err);
        showMessage("‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÑ‡∏ü‡∏•‡πå: " + err.message, 'error');
      }
    });
  </script>
</body>
</html>